/* 
 * Copyright (c) 2026 Eclipse Foundation
 * 
 *  This program and the accompanying materials are made available 
 *  under the terms of the MIT license which is available at
 *  https://opensource.org/license/mit.
 * 
 *  SPDX-License-Identifier: MIT
 * 
 *  Contributors: 
 *     SÃ©bastien Heurtematte - 2026 version.
 * 
 * 
 * // Some portions generated by Co-Pilot
 */
#include "menu.h"
#include "screen.h"
#include "space.h"
#include "fosgame.h"
#include "slotmachine.h"
#include "snake.h"
#include "board_init.h"
#include "ssd1306.h"
#include "tx_api.h"
#include <stdio.h>
#include <string.h>

// Menu state
static MenuItem current_menu_item = MENU_ITEM_SPACE;
static bool menu_active = true;
static int menu_scroll_offset = 0;  // For scrolling through menu items

// Initialize menu
void menu_init(void)
{
    current_menu_item = MENU_ITEM_SPACE;
    menu_active = true;
    printf("[MENU] Menu initialized\r\n");
}

// Display menu on screen
void menu_display(void)
{
    ssd1306_Fill(Black);
    
    // Title (smaller font)
    ssd1306_SetCursor(30, 0);
    ssd1306_WriteString("ARCADE MENU", Font_7x10, White);
    
    // Draw separator line
    for (int i = 0; i < 128; i++)
    {
        ssd1306_DrawPixel(i, 11, White);
    }
    
    // Calculate visible items (max 4 items can fit between y=14 and y=54)
    const int MAX_VISIBLE_ITEMS = 4;
    const int ITEM_HEIGHT = 10;
    
    // Adjust scroll offset to keep current item visible
    if (current_menu_item < menu_scroll_offset)
    {
        menu_scroll_offset = current_menu_item;
    }
    else if (current_menu_item >= menu_scroll_offset + MAX_VISIBLE_ITEMS)
    {
        menu_scroll_offset = current_menu_item - MAX_VISIBLE_ITEMS + 1;
    }
    
    // Display visible menu items
    int visible_count = 0;
    for (int i = menu_scroll_offset; i < MENU_ITEM_COUNT && visible_count < MAX_VISIBLE_ITEMS; i++)
    {
        int y_pos = 14 + (visible_count * ITEM_HEIGHT);
        
        // Highlight selected item
        if (i == current_menu_item)
        {
            // Draw selection indicator (arrow)
            ssd1306_SetCursor(2, y_pos);
            ssd1306_WriteString(">", Font_7x10, White);
        }
        
        // Draw menu item text
        ssd1306_SetCursor(12, y_pos);
        
        // Shorten text for small items to fit on screen
        char display_text[32];
        if (i == MENU_ITEM_SPACE)
        {
            snprintf(display_text, sizeof(display_text), "1.INVADERS");
        }
        else if (i == MENU_ITEM_SNAKE)
        {
            snprintf(display_text, sizeof(display_text), "2.SNAKE");
        }
        else if (i == MENU_ITEM_SLOTMACHINE)
        {
            snprintf(display_text, sizeof(display_text), "3.SLOT MACH");
        }
        else if (i == MENU_ITEM_FOSGAME)
        {
            snprintf(display_text, sizeof(display_text), "4.FOSGAME");
        }
        else if (i == MENU_ITEM_ECLIPSE)
        {
            snprintf(display_text, sizeof(display_text), "5.ECLIPSE");
        }
        ssd1306_WriteString(display_text, Font_7x10, White);
        
        visible_count++;
    }
    
    // Show scroll indicators if needed
    if (menu_scroll_offset > 0)
    {
        // Up arrow
        ssd1306_SetCursor(120, 14);
        ssd1306_WriteString("^", Font_7x10, White);
    }
    if (menu_scroll_offset + MAX_VISIBLE_ITEMS < MENU_ITEM_COUNT)
    {
        // Down arrow
        ssd1306_SetCursor(120, 44);
        ssd1306_WriteString("v", Font_7x10, White);
    }
    
    // Instructions at bottom
    ssd1306_SetCursor(2, 54);
    ssd1306_WriteString("A:Next B:Select", Font_7x10, White);
    
    ssd1306_UpdateScreen();
    
    printf("[MENU] Displaying menu, current selection: %d\r\n", current_menu_item);
}

// Navigate to next menu item
void menu_navigate_next(void)
{
    if (!menu_active)
        return;
    
    current_menu_item = (current_menu_item + 1) % MENU_ITEM_COUNT;
    printf("[MENU] Navigated to item: %d\r\n", current_menu_item);
    menu_display();
}

// Select current menu item
void menu_select_item(void)
{
    if (!menu_active)
    {
        printf("[MENU] select_item called but menu not active!\r\n");
        return;
    }
    
    printf("[MENU] Item selected: %d\r\n", current_menu_item);
    
    switch (current_menu_item)
    {
        case MENU_ITEM_SPACE:
            printf("[MENU] Starting Space Invaders game...\r\n");
            space_set_state(SPACE_STATE_PLAYING);
            printf("[MENU] Game state set to PLAYING\r\n");
            menu_active = false;
            printf("[MENU] Menu deactivated (menu_active = false)\r\n");
            space_invaders_game();
            // When game ends, return to menu
            menu_active = true;
            menu_display();
            break;
            
        case MENU_ITEM_ECLIPSE:
            printf("[MENU] Showing Eclipse Foundation logo...\r\n");
            menu_active = false;
            screen_draw_smiley();
            
            // Wait for button press or 10 seconds timeout
            printf("[MENU] Press any button to return to menu...\r\n");
            int timeout = 0;
            bool waiting = true;
            while (waiting && timeout < 1000)  // 10 seconds max
            {
                // Check if any button is pressed
                if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
                {
                    // Wait for button release
                    while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
                    {
                        tx_thread_sleep(5);
                    }
                    waiting = false;
                }
                tx_thread_sleep(10);  // 100ms
                timeout++;
            }
            
            printf("[MENU] Returning to menu...\r\n");
            menu_active = true;
            menu_display();
            break;
            
        case MENU_ITEM_FOSGAME:
            printf("[MENU] Starting FOSGAME lottery...\r\n");
            menu_active = false;
            fosgame_run();
            
            // Wait for button press or 10 seconds timeout
            printf("[MENU] Press any button to return to menu...\r\n");
            timeout = 0;
            waiting = true;
            while (waiting && timeout < 1000)  // 10 seconds max
            {
                // Check if any button is pressed
                if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
                {
                    // Wait for button release
                    while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
                    {
                        tx_thread_sleep(5);
                    }
                    waiting = false;
                }
                tx_thread_sleep(10);  // 100ms
                timeout++;
            }
            
            printf("[MENU] Returning to menu...\r\n");
            menu_active = true;
            menu_display();
            break;
            
        case MENU_ITEM_SLOTMACHINE:
            printf("[MENU] Starting Slot Machine game...\r\n");
            menu_active = false;
            slotmachine_run();
            
            // Wait for button press or 10 seconds timeout
            printf("[MENU] Press any button to return to menu...\r\n");
            timeout = 0;
            waiting = true;
            while (waiting && timeout < 1000)  // 10 seconds max
            {
                // Check if any button is pressed
                if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
                {
                    // Wait for button release
                    while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
                    {
                        tx_thread_sleep(5);
                    }
                    waiting = false;
                }
                tx_thread_sleep(10);  // 100ms
                timeout++;
            }
            
            printf("[MENU] Returning to menu...\r\n");
            menu_active = true;
            menu_display();
            break;

            
        case MENU_ITEM_SNAKE:
            printf("[MENU] Starting Snake game...\r\n");
            menu_active = false;
            snake_game();
            
            // Game returns when finished
            printf("[MENU] Returning to menu...\r\n");
            menu_active = true;
            menu_display();
            break;
            
        default:
            printf("[MENU] Unknown menu item\r\n");
            menu_active = true;
            menu_display();
            break;
    }
}

// Check if menu is active
bool menu_is_active(void)
{
    return menu_active;
}

// Set menu active state
void menu_set_active(bool active)
{
    menu_active = active;
    if (active)
    {
        printf("[MENU] Menu reactivated\r\n");
        menu_display();
    }
}

// Button A handler for menu - navigate to next item
void menu_handle_button_a(void)
{
    menu_navigate_next();
}

// Button B handler for menu - select current item
void menu_handle_button_b(void)
{
    menu_select_item();
}
