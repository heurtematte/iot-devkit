/* 
 * Copyright (c) 2026 Eclipse Foundation
 * 
 *  This program and the accompanying materials are made available 
 *  under the terms of the MIT license which is available at
 *  https://opensource.org/license/mit.
 * 
 *  SPDX-License-Identifier: MIT
 * 
 *  Contributors: 
 *     SÃ©bastien Heurtematte - 2026 version.
 * 
 * 
 * // Some portions generated by Co-Pilot
 */

#include "space.h"
#include "screen.h"
#include "board_init.h"
#include "menu.h"
#include "tx_api.h"
#include "ssd1306.h"
#include <stdio.h>

// Alien enemy bitmaps (8x8 pixels)
// Alien type 1 - Classic invader
static const uint8_t alien1_bitmap[] = {
    0x18,  // ...##...
    0x3C,  // ..####..
    0x7E,  // .######.
    0xDB,  // ##.##.##
    0xFF,  // ########
    0x24,  // ..#..#..
    0x5A,  // .#.##.#.
    0xA5   // #.#..#.#
};

// Alien type 2 - Octopus style
static const uint8_t alien2_bitmap[] = {
    0x3C,  // ..####..
    0x7E,  // .######.
    0xBD,  // #.####.#
    0xFF,  // ########
    0xFF,  // ########
    0x66,  // .##..##.
    0x66,  // .##..##.
    0xC3   // ##....##
};

// Alien type 3 - Crab style
static const uint8_t alien3_bitmap[] = {
    0x42,  // .#....#.
    0x24,  // ..#..#..
    0x7E,  // .######.
    0xDB,  // ##.##.##
    0xFF,  // ########
    0xFF,  // ########
    0x42,  // .#....#.
    0x24   // ..#..#..
};

// Global game state
static SpaceState current_space_state = SPACE_STATE_MENU;

// Game states
#define GAME_RUNNING 0
#define GAME_OVER 1

// Screen dimensions
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

// Player
typedef struct {
    int x;
    int y;
    int width;
    int height;
} Player;

// Enemy
typedef struct {
    int x;
    int y;
    int width;
    int height;
    int active;
} Enemy;

// Bullet
typedef struct {
    int x;
    int y;
    int active;
} Bullet;

// Explosion effect
typedef struct {
    int x;
    int y;
    int radius;
    int active;
    int frame_counter;  // For animation duration
} Explosion;

// Button state tracking for continuous movement
volatile int button_left_pressed = 0;
volatile int button_right_pressed = 0;

// Game globals
static Player player = {60, 55, 8, 8};
#define MAX_ENEMIES 10
static Enemy enemies[MAX_ENEMIES] = {0};  // Start with no enemies
static int enemy_spawn_counter = 0;  // Counter for spawning enemies
#define ENEMY_SPAWN_INTERVAL 50  // Spawn every 50 game ticks (~500ms)

// Multiple bullets (infinite firing)
#define MAX_BULLETS 10
static Bullet bullets[MAX_BULLETS] = {0};

// Lives and score system
static int lives = 3;           // Player lives (max 3)

// Update RGB LED color based on lives
static void update_lives_led(void)
{
    if (lives >= 3)
    {
        // Green: 3 lives
        RGB_LED_SET_R(0);
        RGB_LED_SET_G(2047);
        RGB_LED_SET_B(0);
    }
    else if (lives == 2)
    {
        // Orange: 2 lives (red + green)
        RGB_LED_SET_R(2047);
        RGB_LED_SET_G(1000);
        RGB_LED_SET_B(0);
    }
    else if (lives == 1)
    {
        // Red: 1 life
        RGB_LED_SET_R(2047);
        RGB_LED_SET_G(0);
        RGB_LED_SET_B(0);
    }
    else
    {
        // Off: no lives
        RGB_LED_SET_R(0);
        RGB_LED_SET_G(0);
        RGB_LED_SET_B(0);
    }
}
static int final_score = 0;     // Store final score

// Explosions
#define MAX_EXPLOSIONS 5
static Explosion explosions[MAX_EXPLOSIONS] = {0};
static int game_state = GAME_RUNNING;
static int score = 0;
static int game_running = 1;

// Simple random number generator
static int game_rand(int max)
{
    static unsigned int seed = 12345;
    seed = (seed * 1103515245 + 12345) & 0x7fffffff;
    return seed % max;
}

// Draw player (triangle shape made with pixels)
static void draw_player(Player *p)
{
    // Draw a simple triangle for the player using pixels
    // Top point
    ssd1306_DrawPixel(p->x, p->y, White);
    
    // Left side
    ssd1306_DrawPixel(p->x - 2, p->y + 2, White);
    ssd1306_DrawPixel(p->x - 2, p->y + 3, White);
    ssd1306_DrawPixel(p->x - 2, p->y + 4, White);
    
    // Right side
    ssd1306_DrawPixel(p->x + 2, p->y + 2, White);
    ssd1306_DrawPixel(p->x + 2, p->y + 3, White);
    ssd1306_DrawPixel(p->x + 2, p->y + 4, White);
    
    // Bottom
    ssd1306_DrawPixel(p->x - 1, p->y + 4, White);
    ssd1306_DrawPixel(p->x + 1, p->y + 4, White);
}

// Draw enemy bitmap
static void draw_enemy(Enemy *e)
{
    if (!e->active)
        return;
    
    // Choose bitmap based on position to get variety
    const uint8_t* bitmap;
    int type = (e->x / 40) % 3;  // Type based on position
    
    switch (type)
    {
        case 0:
            bitmap = alien1_bitmap;
            break;
        case 1:
            bitmap = alien2_bitmap;
            break;
        case 2:
            bitmap = alien3_bitmap;
            break;
        default:
            bitmap = alien1_bitmap;
    }
    
    // Draw 8x8 bitmap
    for (int row = 0; row < 8; row++)
    {
        uint8_t byte = bitmap[row];
        for (int col = 0; col < 8; col++)
        {
            if (byte & (0x80 >> col))
            {
                ssd1306_DrawPixel(e->x + col, e->y + row, White);
            }
        }
    }
}

// Draw all bullets
static void draw_bullets(void)
{
    for (int i = 0; i < MAX_BULLETS; i++)
    {
        if (bullets[i].active)
        {
            ssd1306_DrawPixel(bullets[i].x, bullets[i].y, White);
            ssd1306_DrawPixel(bullets[i].x + 1, bullets[i].y, White);
        }
    }
}

// Draw explosion effect (circle/star pattern)
static void draw_explosion(Explosion *exp)
{
    if (!exp->active)
        return;
    
    int radius = exp->radius;
    
    // Draw explosion pattern (diamond/star shape)
    // Center
    ssd1306_DrawPixel(exp->x, exp->y, White);
    
    // Rays from center
    for (int i = 1; i <= radius; i++)
    {
        // Four directions: up, down, left, right
        ssd1306_DrawPixel(exp->x, exp->y - i, White);      // Up
        ssd1306_DrawPixel(exp->x, exp->y + i, White);      // Down
        ssd1306_DrawPixel(exp->x - i, exp->y, White);      // Left
        ssd1306_DrawPixel(exp->x + i, exp->y, White);      // Right
        
        // Diagonals
        if (i <= radius - 1)
        {
            ssd1306_DrawPixel(exp->x - i, exp->y - i, White);  // Top-left
            ssd1306_DrawPixel(exp->x + i, exp->y - i, White);  // Top-right
            ssd1306_DrawPixel(exp->x - i, exp->y + i, White);  // Bottom-left
            ssd1306_DrawPixel(exp->x + i, exp->y + i, White);  // Bottom-right
        }
    }
}

// Draw all explosions
static void draw_explosions(void)
{
    for (int i = 0; i < MAX_EXPLOSIONS; i++)
    {
        if (explosions[i].active)
        {
            draw_explosion(&explosions[i]);
        }
    }
}

// Check collision between bullet and enemy
static int check_collision(Bullet *b, Enemy *e)
{
    return (b->x >= e->x && b->x <= e->x + e->width &&
            b->y >= e->y && b->y <= e->y + e->height);
}

// Create explosion at position
static void create_explosion(int x, int y)
{
    // Find free explosion slot
    for (int i = 0; i < MAX_EXPLOSIONS; i++)
    {
        if (!explosions[i].active)
        {
            explosions[i].x = x;
            explosions[i].y = y;
            explosions[i].radius = 4;
            explosions[i].active = 1;
            explosions[i].frame_counter = 10; // Display for 10 frames
            printf("[GAME] Explosion at x=%d, y=%d!\r\n", x, y);
            return;
        }
    }
}

// Update explosions (animation)
static void update_explosions(void)
{
    for (int i = 0; i < MAX_EXPLOSIONS; i++)
    {
        if (explosions[i].active)
        {
            explosions[i].frame_counter--;
            if (explosions[i].frame_counter <= 0)
            {
                explosions[i].active = 0;
            }
        }
    }
}

// ===== Game State Management Functions =====

// Get current game state
SpaceState space_get_state(void)
{
    return current_space_state;
}

// Set game state
void space_set_state(SpaceState state)
{
    current_space_state = state;
    printf("[GAME] Game state changed to: %d\r\n", state);
}

// Check collision between enemy and player
static int check_player_collision(Enemy *e, Player *p)
{
    return (e->x < p->x + p->width && e->x + e->width > p->x &&
            e->y < p->y + p->height && e->y + e->height > p->y);
}

// Update collisions with player (lose life if hit)
static void update_player_collisions(void)
{
    for (int i = 0; i < 3; i++)
    {
        if (enemies[i].active && check_player_collision(&enemies[i], &player))
        {
            printf("[GAME] Player hit by enemy! Lives left: %d\r\n", lives - 1);
            lives--;
            update_lives_led();  // Update LED color
            
            // Reset enemy position
            enemies[i].y = 5;
            enemies[i].x = 20 + (i * 44);
            
            if (lives <= 0)
            {
                printf("[GAME] GAME OVER! Final Score: %d\r\n", score);
                final_score = score;
                game_state = GAME_OVER;
            }
        }
    }
}

// Game control functions - called by button callbacks

// Move player left
void space_move_left(void)
{
    if (current_space_state == SPACE_STATE_PLAYING)
    {
        if (player.x > 5)
        {
            player.x -= 5;
            printf("[GAME] Player moved left to x=%d\r\n", player.x);
        }
    }
}

// Move player right
void space_move_right(void)
{
    if (current_space_state == SPACE_STATE_PLAYING)
    {
        if (player.x < SCREEN_WIDTH - 10)
        {
            player.x += 5;
            printf("[GAME] Player moved right to x=%d\r\n", player.x);
        }
    }
}

// Functions to track button states for continuous movement
void space_button_left_pressed(void)
{
    button_left_pressed = 1;
}

void space_button_left_released(void)
{
    button_left_pressed = 0;
}

void space_button_right_pressed(void)
{
    button_right_pressed = 1;
}

void space_button_right_released(void)
{
     button_right_pressed = 0;
}

// Fire bullet
void space_fire_bullet(void)
{
    if (current_space_state == SPACE_STATE_PLAYING)
    {
        // Find first free bullet slot
        for (int i = 0; i < MAX_BULLETS; i++)
        {
            if (!bullets[i].active)
            {
                bullets[i].x = player.x;
                bullets[i].y = player.y - 2;
                bullets[i].active = 1;
                printf("[GAME] Bullet fired! (slot %d) at x=%d, y=%d\r\n", i, bullets[i].x, bullets[i].y);
                return; // Exit after firing one bullet
            }
        }
        // If all bullets are in use, silently ignore (already firing max)
    }
}

// Reset game
void space_reset(void)
{
    printf("[GAME] Game reset requested\r\n");
    if (current_space_state == SPACE_STATE_OVER || current_space_state == SPACE_STATE_MENU)
    {
        space_set_state(SPACE_STATE_PLAYING);
    }
    else
    {
        game_running = 0;
    }
}

// Spawn a new enemy at random position
static void spawn_random_enemy(void)
{
    // Find an inactive enemy slot
    for (int i = 0; i < MAX_ENEMIES; i++)
    {
        if (!enemies[i].active)
        {
            // Random x position (keeping margins)
            enemies[i].x = 10 + game_rand(100);
            enemies[i].y = 5;
            enemies[i].width = 8;
            enemies[i].height = 8;
            enemies[i].active = 1;
            printf("[GAME] New enemy spawned at x=%d\r\n", enemies[i].x);
            return;
        }
    }
}

// Move enemies down
static void move_enemies(void)
{
    for (int i = 0; i < MAX_ENEMIES; i++)
    {
        if (enemies[i].active)
        {
            enemies[i].y += 1;
            
            // Check if enemy reached bottom
            if (enemies[i].y > SCREEN_HEIGHT)
            {
                enemies[i].y = 5;
                enemies[i].x = 20 + (i * 44);
            }
        }
    }
}

// Update all bullets with collision detection
static void update_bullets(void)
{
    for (int b = 0; b < MAX_BULLETS; b++)
    {
        if (bullets[b].active)
        {
            bullets[b].y -= 3; // Bullet speed
            
            // Check collision with enemies
            for (int i = 0; i < MAX_ENEMIES; i++)
            {
                if (enemies[i].active && check_collision(&bullets[b], &enemies[i]))
                {
                    printf("[GAME] HIT! Enemy %d destroyed!\r\n", i);
                    
                    // Create explosion at enemy position
                    create_explosion(enemies[i].x + 3, enemies[i].y + 3);
                    
                    // Remove enemy and bullet
                    enemies[i].active = 0;
                    bullets[b].active = 0;
                    score += 10;
                    printf("[GAME] Score: %d\r\n", score);
                    break;
                }
            }
            
            // Check if bullet left screen
            if (bullets[b].y < 0)
            {
                bullets[b].active = 0;
            }
        }
    }
}

// Render game screen
static void render_game(void)
{
    ssd1306_Fill(Black);
    
    // Draw player
    draw_player(&player);
    
    // Draw enemies
    for (int i = 0; i < MAX_ENEMIES; i++)
    {
        draw_enemy(&enemies[i]);
    }
    
    // Draw all bullets
    draw_bullets();
    
    // Draw all explosions
    draw_explosions();
    
    // Draw score only
    char info_str[32];
    snprintf(info_str, sizeof(info_str), "Score:%d", score);
    ssd1306_SetCursor(2, 0);
    ssd1306_WriteString(info_str, Font_11x18, White);
    
    ssd1306_UpdateScreen();
}

// Game loop
void space_invaders_game(void)
{
    printf("[GAME] Starting Space Invaders!\r\n");
    printf("[GAME] Controls: Button A = Move Left, Button B = Move Right\r\n");
    printf("[GAME] Automatic infinite firing enabled!\r\n");
    
    // Reset game state
    player.x = 60;
    player.y = 55;
    score = 0;
    enemy_spawn_counter = 0;  // Reset spawn counter
    lives = 3;
    update_lives_led();  // Initialize LED to green (3 lives)
    game_state = GAME_RUNNING;
    game_running = 1;
    current_space_state = SPACE_STATE_PLAYING;
    
    // CRITICAL: Reset button states to prevent stuck buttons
    button_left_pressed = 0;
    button_right_pressed = 0;
    printf("[GAME] Button states reset: left=%d, right=%d\r\n", button_left_pressed, button_right_pressed);
    printf("[GAME] Game state set to: %d (should be 1 for PLAYING)\r\n", current_space_state);
    
    // Reset enemies (start with 3 initial enemies)
    for (int i = 0; i < MAX_ENEMIES; i++)
    {
        if (i < 3)
        {
            enemies[i].active = 1;
            enemies[i].x = 20 + (i * 44);
            enemies[i].y = 5;
            enemies[i].width = 8;
            enemies[i].height = 8;
        }
        else
        {
            enemies[i].active = 0;
        }
    }
    
    // Initialize bullet array (all inactive)
    for (int i = 0; i < MAX_BULLETS; i++)
    {
        bullets[i].active = 0;
    }
    
    // Initialize explosions
    for (int i = 0; i < MAX_EXPLOSIONS; i++)
    {
        explosions[i].active = 0;
    }
    
    uint32_t auto_fire_counter = 0;  // Counter for automatic firing
    
    // Main game loop
    while (game_running && game_state == GAME_RUNNING && current_space_state == SPACE_STATE_PLAYING)
    {
        // Game runs at ~20 FPS (50ms per frame)
        
        // Automatic firing every 3 frames (constant stream of bullets)
        auto_fire_counter++;
        if (auto_fire_counter >= 3)
        {
            space_fire_bullet();  // Fire automatically
            auto_fire_counter = 0;
        }
        
        // Read GPIO directly (polling) - works better than interrupts with ThreadX
        if (BUTTON_A_IS_PRESSED && player.x > 5)
        {
            player.x -= 2;   // Move left
        }

        if (BUTTON_B_IS_PRESSED && player.x < SCREEN_WIDTH - 10)
        {
            player.x += 2;   // Move right
        }
        
        // Update game logic
        move_enemies();
        
        // Spawn new enemies continuously
        enemy_spawn_counter++;
        if (enemy_spawn_counter >= ENEMY_SPAWN_INTERVAL)
        {
            spawn_random_enemy();
            enemy_spawn_counter = 0;
        }
        
        update_player_collisions();  // Check if player is hit (lose life)
        update_bullets();     // Update ALL bullets with collision detection
        update_explosions();  // Animate explosions
        
        // Render
        render_game();
        
        // Frame delay
        tx_thread_sleep(5); // ~50ms delay for game speed
        
        // Check if all enemies defeated
        int all_defeated = 1;
        for (int i = 0; i < 3; i++)
        {
            if (enemies[i].active)
            {
                all_defeated = 0;
                break;
            }
        }
        
        if (all_defeated)
        {
            // Reset enemies for next round
            for (int i = 0; i < 3; i++)
            {
                enemies[i].active = 1;
                enemies[i].x = 20 + (i * 44);
                enemies[i].y = 5;
            }
        }
    }
    
    // Game Over screen - display final score
    ssd1306_Fill(Black);
    ssd1306_SetCursor(15, 10);
    ssd1306_WriteString("GAME OVER", Font_11x18, White);
    
    ssd1306_SetCursor(10, 30);
    char score_display[32];
    snprintf(score_display, sizeof(score_display), "Score:%d", final_score);
    ssd1306_WriteString(score_display, Font_11x18, White);
    
    ssd1306_SetCursor(5, 50);
    ssd1306_WriteString("Press button", Font_7x10, White);
    ssd1306_UpdateScreen();
    
    printf("[GAME] ========== GAME OVER ==========\r\n");
    printf("[GAME] Final Score: %d\r\n", final_score);
    printf("[GAME] ================================\r\n");
    
    // Set game state to OVER so we can detect button press
    space_set_state(SPACE_STATE_OVER);
    
    // Wait for button press to return to menu
    printf("[GAME] Waiting for button press to return to menu...\r\n");
    bool button_was_released = true;  // Track if button was released first
    
    while (current_space_state == SPACE_STATE_OVER)
    {
        // Wait for clean button press (released then pressed)
        bool button_a = BUTTON_A_IS_PRESSED;
        bool button_b = BUTTON_B_IS_PRESSED;
        
        if (!button_a && !button_b)
        {
            button_was_released = true;
        }
        
        if (button_was_released && (button_a || button_b))
        {
            // Button pressed - return to menu
            printf("[GAME] Button pressed, returning to menu\r\n");
            menu_set_active(true);
            menu_display();
            break;
        }
        
        tx_thread_sleep(10);  // Sleep 100ms
    }
}

// Stop game
void space_stop(void)
{
    game_running = 0;
}
