/* 
 * Copyright (c) 2026 Eclipse Foundation
 * 
 *  This program and the accompanying materials are made available 
 *  under the terms of the MIT license which is available at
 *  https://opensource.org/license/mit.
 * 
 *  SPDX-License-Identifier: MIT
 * 
 *  Contributors: 
 *     SÃ©bastien Heurtematte - 2026 version.
 * 
 * 
 * // Some portions generated by Co-Pilot
 */

#include "fosgame.h"
#include "ssd1306.h"
#include "tx_api.h"
#include "board_init.h"
#include <stdio.h>

#define PRIZE_COUNT 10

// Prize information structure
typedef struct {
    const char* name;
    uint8_t x_pos_single;    // X position for single line display
    uint8_t x_pos_result;    // X position for result display (after "YOU WIN:")
} PrizeInfo;

// Prize information table
static const PrizeInfo prize_table[PRIZE_COUNT] = {
    {"TRY AGAIN LATER!", 10, 10},   // PRIZE_LOSE
    {"T-SHIRT!", 8, 8},              // PRIZE_TSHIRT
    {"CAP!", 28, 28},                // PRIZE_CAP
    {"COOKIES!", 10, 10},            // PRIZE_COOKIES
    {"GPS TRACKER!", 0, 0},          // PRIZE_GPS_TRACKER
    {"BEANIES!", 10, 10},            // PRIZE_BEANIES
    {"BASECAPS!", 5, 5},             // PRIZE_BASECAPS
    {"LUGGAGE TAG!", 0, 0},          // PRIZE_LUGGAGE_TAG
    {"BOTTLE OPENER!", 0, 0},        // PRIZE_BOTTLE_OPENER
    {"PENS!", 30, 30}                // PRIZE_PENS
};

// Get next prize in rotation
static PrizeType get_next_prize(PrizeType current)
{
    return (PrizeType)((current + 1) % PRIZE_COUNT);
}

// Helper function to get prize name
static const char* get_prize_name(PrizeType prize)
{
    if (prize >= 0 && prize < PRIZE_COUNT)
    {
        return prize_table[prize].name;
    }
    return "UNKNOWN";
}

// Display the scrolling prizes
static void draw_fosgame_display(PrizeType current_prize, bool spinning)
{
    ssd1306_Fill(Black);
    
    // Title
    ssd1306_SetCursor(15, 0);
    ssd1306_WriteString("FOSGAME", Font_11x18, White);
    
    // Draw separator line
    for (int i = 0; i < 128; i++)
    {
        ssd1306_DrawPixel(i, 20, White);
    }
    
    // Display current prize in the center
    if (current_prize >= 0 && current_prize < PRIZE_COUNT)
    {
        ssd1306_SetCursor(prize_table[current_prize].x_pos_single, 28);
        ssd1306_WriteString((char*)prize_table[current_prize].name, Font_11x18, White);
    }
    
    // Show instructions if spinning
    if (spinning)
    {
        ssd1306_SetCursor(5, 54);
        ssd1306_WriteString("Press A or B", Font_7x10, White);
    }
    
    ssd1306_UpdateScreen();
}

// Display final result with "YOU WIN:" prefix for prizes
static void draw_fosgame_result(PrizeType prize)
{
    ssd1306_Fill(Black);
    
    // Title
    ssd1306_SetCursor(15, 0);
    ssd1306_WriteString("FOSGAME", Font_11x18, White);
    
    // Draw separator line
    for (int i = 0; i < 128; i++)
    {
        ssd1306_DrawPixel(i, 20, White);
    }
    
    // Display result with proper formatting
    if (prize >= 0 && prize < PRIZE_COUNT)
    {
        if (prize == PRIZE_LOSE)
        {
            // Special case for losing
            ssd1306_SetCursor(prize_table[prize].x_pos_single, 28);
            ssd1306_WriteString((char*)prize_table[prize].name, Font_11x18, White);
        }
        else
        {
            // Win case: show "YOU WIN:" followed by prize name
            ssd1306_SetCursor(10, 28);
            ssd1306_WriteString((char*)"YOU WIN:", Font_11x18, White);
            ssd1306_SetCursor(prize_table[prize].x_pos_result, 46);
            ssd1306_WriteString((char*)prize_table[prize].name, Font_11x18, White);
        }
        printf("[FOSGAME] Result: %s\r\n", prize_table[prize].name);
    }
    
    ssd1306_UpdateScreen();
}

// Run FOSGAME lottery with scrolling selection
void fosgame_run(void)
{
    printf("[FOSGAME] Starting lottery game...\r\n");
    
    // Show instruction
    ssd1306_Fill(Black);
    ssd1306_SetCursor(15, 0);
    ssd1306_WriteString("FOSGAME", Font_11x18, White);
    ssd1306_SetCursor(5, 25);
    ssd1306_WriteString("Press A or B", Font_7x10, White);
    ssd1306_SetCursor(5, 37);
    ssd1306_WriteString("to stop the", Font_7x10, White);
    ssd1306_SetCursor(5, 49);
    ssd1306_WriteString("selection", Font_7x10, White);
    ssd1306_UpdateScreen();
    tx_thread_sleep(200);  // 2 seconds
    
    // Wait for all buttons to be released before starting
    while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
    {
        tx_thread_sleep(1);
    }
    
    // Start scrolling through prizes
    printf("[FOSGAME] Scrolling through prizes... Press A or B to stop\r\n");
    PrizeType current_prize = PRIZE_LOSE;
    bool spinning = true;
    
    while (spinning)
    {
        current_prize = get_next_prize(current_prize);
        draw_fosgame_display(current_prize, true);
        tx_thread_sleep(15);  // 150ms between changes (adjustable for speed)
        
        // Check for button press
        if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
        {
            // Wait for release
            while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(1);
            }
            spinning = false;
        }
    }
    
    // Display final result with proper formatting
    draw_fosgame_result(current_prize);
    
    printf("[FOSGAME] Final prize: %s\r\n", get_prize_name(current_prize));
    
    // Wait for button press to continue
    printf("[FOSGAME] Press any button to continue...\r\n");
    bool waiting = true;
    while (waiting)
    {
        if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
        {
            // Wait for release
            while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(1);
            }
            waiting = false;
        }
        tx_thread_sleep(10);
    }
}

// Get random prize based on lottery odds (kept for backwards compatibility)
PrizeType fosgame_get_prize(void)
{
    // Use ThreadX timer as random seed
    ULONG tick = tx_time_get();
    
    // Simple pseudo-random number generator
    int random_num = (tick * 1103515245 + 12345) % 100;
    
    // Lottery distribution (equal 10% each)
    // Each prize has 10% probability (0-9, 10-19, 20-29, etc.)
    return (PrizeType)(random_num / 10);
}
