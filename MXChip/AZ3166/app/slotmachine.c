/* 
 * Copyright (c) 2026 Eclipse Foundation
 * 
 *  This program and the accompanying materials are made available 
 *  under the terms of the MIT license which is available at
 *  https://opensource.org/license/mit.
 * 
 *  SPDX-License-Identifier: MIT
 * 
 *  Contributors: 
 *     SÃ©bastien Heurtematte - 2026 version.
 * 
 * 
 * // Some portions generated by Co-Pilot
 */

#include "slotmachine.h"
#include "ssd1306.h"
#include "tx_api.h"
#include "board_init.h"
#include <stdio.h>

// Mario symbol bitmaps (16x16 pixels)
// Star bitmap - 5-pointed star
static const uint8_t star_bitmap[] = {
    0x00, 0x00,  // ................
    0x01, 0x80,  // .......##.......
    0x01, 0x80,  // .......##.......
    0x03, 0xC0,  // ......####......
    0x03, 0xC0,  // ......####......
    0x1F, 0xF8,  // ...##########...
    0x0F, 0xF0,  // ....########....
    0x07, 0xE0,  // .....######.....
    0x0F, 0xF0,  // ....########....
    0x1E, 0x78,  // ...####..####...
    0x3C, 0x3C,  // ..####....####..
    0x78, 0x1E,  // .####......####.
    0x70, 0x0E,  // .###........###.
    0x20, 0x04,  // ..#..........#..
    0x00, 0x00,  // ................
    0x00, 0x00   // ................
};

// Mushroom bitmap
static const uint8_t mushroom_bitmap[] = {
    0x00, 0x00,  // ................
    0x07, 0xE0,  // .....######.....
    0x1F, 0xF8,  // ...##########...
    0x3F, 0xFC,  // ..############..
    0x7E, 0x7E,  // .#####..#####...
    0x7E, 0x7E,  // .#####..#####...
    0x7F, 0xFE,  // .#############..
    0x7F, 0xFE,  // .#############..
    0x3F, 0xFC,  // ..############..
    0x07, 0xE0,  // .....######.....
    0x07, 0xE0,  // .....######.....
    0x0F, 0xF0,  // ....########....
    0x0F, 0xF0,  // ....########....
    0x07, 0xE0,  // .....######.....
    0x00, 0x00,  // ................
    0x00, 0x00   // ................
};

// Flower bitmap
static const uint8_t flower_bitmap[] = {
    0x00, 0x00,  // ................
    0x11, 0x88,  // ...#...##...#...
    0x3B, 0xDC,  // ..###.####.###..
    0x3F, 0xFC,  // ..############..
    0x1F, 0xF8,  // ...##########...
    0x0F, 0xF0,  // ....########....
    0x07, 0xE0,  // .....######.....
    0x03, 0xC0,  // ......####......
    0x01, 0x80,  // .......##.......
    0x01, 0x80,  // .......##.......
    0x01, 0x80,  // .......##.......
    0x01, 0x80,  // .......##.......
    0x03, 0xC0,  // ......####......
    0x03, 0xC0,  // ......####......
    0x00, 0x00,  // ................
    0x00, 0x00   // ................
};

static const char* get_symbol_name(SlotSymbol symbol)
{
    switch (symbol)
    {
        case SYMBOL_STAR:
            return "STAR";
        case SYMBOL_MUSHROOM:
            return "MUSHROOM";
        case SYMBOL_FLOWER:
            return "FLOWER";
        default:
            return "UNKNOWN";
    }
}

// Get random symbol
static SlotSymbol get_random_symbol(void)
{
    static ULONG seed = 0;
    ULONG tick = tx_time_get();
    
    // Mix the seed with current time for better randomness
    seed = (seed * 1103515245 + 12345 + tick) % 2147483647;
    int random_num = (seed ^ tick) % SYMBOL_COUNT;
    
    return (SlotSymbol)random_num;
}

// Helper function to draw a bitmap at a specific position
static void draw_symbol_bitmap(uint8_t x, uint8_t y, SlotSymbol symbol)
{
    const uint8_t* bitmap;
    
    switch (symbol)
    {
        case SYMBOL_STAR:
            bitmap = star_bitmap;
            break;
        case SYMBOL_MUSHROOM:
            bitmap = mushroom_bitmap;
            break;
        case SYMBOL_FLOWER:
            bitmap = flower_bitmap;
            break;
        default:
            return;
    }
    
    // Draw 16x16 bitmap
    for (int row = 0; row < 16; row++)
    {
        uint8_t byte1 = bitmap[row * 2];
        uint8_t byte2 = bitmap[row * 2 + 1];
        
        for (int col = 0; col < 8; col++)
        {
            if (byte1 & (0x80 >> col))
            {
                ssd1306_DrawPixel(x + col, y + row, White);
            }
            if (byte2 & (0x80 >> col))
            {
                ssd1306_DrawPixel(x + col + 8, y + row, White);
            }
        }
    }
}

// Draw slot machine display
static void draw_slot_display(SlotSymbol slot1, SlotSymbol slot2, SlotSymbol slot3, bool spinning1, bool spinning2, bool spinning3)
{
    ssd1306_Fill(Black);
    
    // Title
    ssd1306_SetCursor(10, 0);
    ssd1306_WriteString("SLOT MACHINE", Font_7x10, White);
    
    // Draw separator line
    for (int i = 0; i < 128; i++)
    {
        ssd1306_DrawPixel(i, 11, White);
    }
    
    // Draw slot machine frame (3 boxes)
    // Box 1
    for (int i = 10; i < 40; i++)
    {
        ssd1306_DrawPixel(i, 20, White);
        ssd1306_DrawPixel(i, 45, White);
    }
    for (int i = 20; i < 45; i++)
    {
        ssd1306_DrawPixel(10, i, White);
        ssd1306_DrawPixel(40, i, White);
    }
    
    // Box 2
    for (int i = 49; i < 79; i++)
    {
        ssd1306_DrawPixel(i, 20, White);
        ssd1306_DrawPixel(i, 45, White);
    }
    for (int i = 20; i < 45; i++)
    {
        ssd1306_DrawPixel(49, i, White);
        ssd1306_DrawPixel(79, i, White);
    }
    
    // Box 3
    for (int i = 88; i < 118; i++)
    {
        ssd1306_DrawPixel(i, 20, White);
        ssd1306_DrawPixel(i, 45, White);
    }
    for (int i = 20; i < 45; i++)
    {
        ssd1306_DrawPixel(88, i, White);
        ssd1306_DrawPixel(118, i, White);
    }
    
    // Draw symbols or spinning animation for each slot
    
    // Slot 1 - Show bitmap (spinning or stopped), or ? if not yet started
    if (!spinning1)
    {
        draw_symbol_bitmap(17, 24, slot1);
    }
    else if (spinning1)
    {
        // Slot 1 is active - show changing bitmap
        draw_symbol_bitmap(17, 24, slot1);
    }
    
    // Slot 2 - Show bitmap if stopped, or ? if not yet started
    if (!spinning1 && !spinning2)
    {
        draw_symbol_bitmap(56, 24, slot2);
    }
    else if (!spinning1 && spinning2)
    {
        // Slot 2 is active - show changing bitmap
        draw_symbol_bitmap(56, 24, slot2);
    }
    else
    {
        // Slot 2 not yet started - show ?
        ssd1306_SetCursor(59, 28);
        ssd1306_WriteString("?", Font_11x18, White);
    }
    
    // Slot 3 - Show bitmap if stopped, or ? if not yet started
    if (!spinning1 && !spinning2 && !spinning3)
    {
        draw_symbol_bitmap(95, 24, slot3);
    }
    else if (!spinning1 && !spinning2 && spinning3)
    {
        // Slot 3 is active - show changing bitmap
        draw_symbol_bitmap(95, 24, slot3);
    }
    else
    {
        // Slot 3 not yet started - show ?
        ssd1306_SetCursor(98, 28);
        ssd1306_WriteString("?", Font_11x18, White);
    }
    
    // Instructions
    if (spinning1 || spinning2 || spinning3)
    {
        ssd1306_SetCursor(5, 54);
        ssd1306_WriteString("Press A or B", Font_7x10, White);
    }
    
    ssd1306_UpdateScreen();
}

// Draw result message
static void draw_result(SlotSymbol slot1, SlotSymbol slot2, SlotSymbol slot3)
{
    ssd1306_Fill(Black);
    
    // Title
    ssd1306_SetCursor(10, 0);
    ssd1306_WriteString("SLOT MACHINE", Font_7x10, White);
    
    // Draw separator
    for (int i = 0; i < 128; i++)
    {
        ssd1306_DrawPixel(i, 11, White);
    }
    
    // Show result symbols as bitmaps
    // Draw symbol bitmaps centered horizontally: x positions 24, 56, 88
    draw_symbol_bitmap(24, 16, slot1);
    draw_symbol_bitmap(56, 16, slot2);
    draw_symbol_bitmap(88, 16, slot3);
    
    // Check win conditions
    if (slot1 == slot2 && slot2 == slot3)
    {
        // All three match - WIN
        ssd1306_SetCursor(45, 40);
        ssd1306_WriteString("WIN", Font_11x18, White);
        printf("[SLOT] WIN! Three %s\r\n", get_symbol_name(slot1));
    }
    else
    {
        // Not all match - LOSE
        ssd1306_SetCursor(0, 40);
        ssd1306_WriteString("TRY AGAIN!", Font_11x18, White);
        printf("[SLOT] TRY AGAIN! No match\r\n");
    }
    
    ssd1306_UpdateScreen();
}

// Run slot machine game
void slotmachine_run(void)
{
    printf("[SLOT] Starting Slot Machine game...\r\n");
    
    SlotSymbol slot1, slot2, slot3;
    
    // Show instruction
    ssd1306_Fill(Black);
    ssd1306_SetCursor(5, 0);
    ssd1306_WriteString("SLOT MACHINE", Font_7x10, White);
    ssd1306_SetCursor(5, 20);
    ssd1306_WriteString("Press A or B", Font_7x10, White);
    ssd1306_SetCursor(5, 32);
    ssd1306_WriteString("to stop each", Font_7x10, White);
    ssd1306_SetCursor(5, 44);
    ssd1306_WriteString("reel", Font_7x10, White);
    ssd1306_UpdateScreen();
    tx_thread_sleep(200);  // 2 seconds
    
    // Wait for all buttons to be released before starting
    while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
    {
        tx_thread_sleep(1);
    }
    
    // Slot 1 - Spin until button press
    printf("[SLOT] Spinning slot 1... Press A or B to stop\r\n");
    bool spinning = true;
    while (spinning)
    {
        slot1 = get_random_symbol();
        draw_slot_display(slot1, SYMBOL_STAR, SYMBOL_STAR, true, false, false);
        tx_thread_sleep(100);  // 1000ms (1 sec)
        
        // Check for button press
        if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
        {
            // Wait for release
            while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(1);
            }
            spinning = false;
        }
    }
    draw_slot_display(slot1, SYMBOL_STAR, SYMBOL_STAR, false, false, false);
    tx_thread_sleep(20);
    printf("[SLOT] Slot 1 stopped: %s\r\n", get_symbol_name(slot1));
    
    // Slot 2 - Spin until button press
    printf("[SLOT] Spinning slot 2... Press A or B to stop\r\n");
    spinning = true;
    while (spinning)
    {
        slot2 = get_random_symbol();
        draw_slot_display(slot1, slot2, SYMBOL_STAR, false, true, false);
        tx_thread_sleep(100);  // 1000ms (1 sec)
        
        // Check for button press
        if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
        {
            // Wait for release
            while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(1);
            }
            spinning = false;
        }
    }
    draw_slot_display(slot1, slot2, SYMBOL_STAR, false, false, false);
    tx_thread_sleep(20);
    printf("[SLOT] Slot 2 stopped: %s\r\n", get_symbol_name(slot2));
    
    // Slot 3 - Spin until button press
    printf("[SLOT] Spinning slot 3... Press A or B to stop\r\n");
    spinning = true;
    while (spinning)
    {
        slot3 = get_random_symbol();
        draw_slot_display(slot1, slot2, slot3, false, false, true);
        tx_thread_sleep(100);  // 1000ms (1 sec)
        
        // Check for button press
        if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
        {
            // Wait for release
            while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(1);
            }
            spinning = false;
        }
    }
    draw_slot_display(slot1, slot2, slot3, false, false, false);
    tx_thread_sleep(20);  // Show final combination
    printf("[SLOT] Slot 3 stopped: %s\r\n", get_symbol_name(slot3));
    
    // Display result
    draw_result(slot1, slot2, slot3);
    
    printf("[SLOT] Result: %s - %s - %s\r\n", 
           get_symbol_name(slot1), 
           get_symbol_name(slot2), 
           get_symbol_name(slot3));
    
    // Wait for button press to continue
    printf("[SLOT] Press any button to continue...\r\n");
    bool waiting = true;
    while (waiting)
    {
        if (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
        {
            // Wait for release
            while (BUTTON_A_IS_PRESSED || BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(1);
            }
            waiting = false;
        }
        tx_thread_sleep(10);
    }
}
