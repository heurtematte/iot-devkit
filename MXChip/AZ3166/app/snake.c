/* 
 * Copyright (c) 2026 Eclipse Foundation
 * 
 *  This program and the accompanying materials are made available 
 *  under the terms of the MIT license which is available at
 *  https://opensource.org/license/mit.
 * 
 *  SPDX-License-Identifier: MIT
 * 
 *  Contributors: 
 *     SÃ©bastien Heurtematte - 2026 version.
 * 
 * 
 * // Some portions generated by Co-Pilot
 */

#include "snake.h"
#include "screen.h"
#include "board_init.h"
#include "menu.h"
#include "tx_api.h"
#include "ssd1306.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Screen dimensions for game area
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define SCORE_HEIGHT 12       // Height reserved for score display at top
#define GAME_Y_OFFSET 12      // Vertical offset to start game area below score
#define BLOCK_SIZE 3

// Game area dimensions (in blocks)
#define GAME_WIDTH (SCREEN_WIDTH / BLOCK_SIZE)
#define GAME_HEIGHT ((SCREEN_HEIGHT - GAME_Y_OFFSET) / BLOCK_SIZE)

// Snake constants
#define MAX_SNAKE_LENGTH 200
#define INITIAL_SNAKE_LENGTH 3
#define FRAMES_PER_MOVE 150000  // Adjust this for game speed: higher = slower (150000 works well)

// Game state
static SnakeState current_state = SNAKE_STATE_OVER;
static SnakeSegment snake[MAX_SNAKE_LENGTH];
static int snake_length;
static Direction current_direction;
static Direction next_direction;  // Buffer for next direction to avoid instant reverse
static int food_x;
static int food_y;
static int score;
static bool game_running;

// Forward declarations
static void draw_game(void);
static void update_game(void);
static void spawn_food(void);
static bool check_collision(void);
static bool check_self_collision(void);
static void draw_block(int x, int y, bool filled);
static int random_range(int min, int max);

// Get current state
SnakeState snake_get_state(void)
{
    return current_state;
}

// Set state
void snake_set_state(SnakeState state)
{
    current_state = state;
}

// Reset the game
void snake_reset(void)
{
    printf("[SNAKE] Resetting game...\r\n");
    
    // Initialize snake in the middle-left, facing right (so it has space to move)
    snake_length = INITIAL_SNAKE_LENGTH;
    int start_x = GAME_WIDTH / 4;  // Start at 1/4 from left (more space to the right)
    int start_y = GAME_HEIGHT / 2;
    
    for (int i = 0; i < snake_length; i++)
    {
        snake[i].x = start_x - i;
        snake[i].y = start_y;
    }
    
    current_direction = DIRECTION_RIGHT;
    next_direction = DIRECTION_RIGHT;
    score = 0;
    
    printf("[SNAKE] Start pos: (%d,%d), Dir: RIGHT\r\n", start_x, start_y);
    
    // Spawn first food
    spawn_food();
    
    current_state = SNAKE_STATE_PLAYING;
    game_running = true;
    
    printf("[SNAKE] Game reset complete. Snake length: %d\r\n", snake_length);
}

// Turn left (relative to current direction)
void snake_button_left_pressed(void)
{
    printf("[SNAKE] snake_button_left_pressed called! state=%d\r\n", current_state);
    
    if (current_state != SNAKE_STATE_PLAYING)
    {
        printf("[SNAKE] Button A ignored - game not playing!\r\n");
        return;
    }
    
    Direction old_dir = next_direction;
    
    // Turn left relative to current direction
    switch (current_direction)
    {
        case DIRECTION_UP:
            next_direction = DIRECTION_LEFT;
            break;
        case DIRECTION_LEFT:
            next_direction = DIRECTION_DOWN;
            break;
        case DIRECTION_DOWN:
            next_direction = DIRECTION_RIGHT;
            break;
        case DIRECTION_RIGHT:
            next_direction = DIRECTION_UP;
            break;
    }
    
    printf("[SNAKE] Button A - Turn LEFT: current=%d, next=%d -> %d\r\n", current_direction, old_dir, next_direction);
}

// Turn right (relative to current direction)
void snake_button_right_pressed(void)
{
    printf("[SNAKE] snake_button_right_pressed called! state=%d\r\n", current_state);
    
    if (current_state != SNAKE_STATE_PLAYING)
    {
        printf("[SNAKE] Button B ignored - game not playing!\r\n");
        return;
    }
    
    Direction old_dir = next_direction;
    
    // Turn right relative to current direction
    switch (current_direction)
    {
        case DIRECTION_UP:
            next_direction = DIRECTION_RIGHT;
            break;
        case DIRECTION_RIGHT:
            next_direction = DIRECTION_DOWN;
            break;
        case DIRECTION_DOWN:
            next_direction = DIRECTION_LEFT;
            break;
        case DIRECTION_LEFT:
            next_direction = DIRECTION_UP;
            break;
    }
    
    printf("[SNAKE] Button B - Turn RIGHT: current=%d, next=%d -> %d\r\n", current_direction, old_dir, next_direction);
}

// Generate random number in range
static int random_range(int min, int max)
{
    return min + (rand() % (max - min + 1));
}

// Spawn food at random location
static void spawn_food(void)
{
    bool valid_position = false;
    
    while (!valid_position)
    {
        food_x = random_range(1, GAME_WIDTH - 2);
        food_y = random_range(1, GAME_HEIGHT - 2);
        
        // Check if food spawns on snake
        valid_position = true;
        for (int i = 0; i < snake_length; i++)
        {
            if (snake[i].x == food_x && snake[i].y == food_y)
            {
                valid_position = false;
                break;
            }
        }
    }
    
    printf("[SNAKE] Food spawned at (%d, %d)\r\n", food_x, food_y);
}

// Check if snake hits border
static bool check_collision(void)
{
    // Check border collision
    if (snake[0].x <= 0 || snake[0].x >= GAME_WIDTH - 1 ||
        snake[0].y <= 0 || snake[0].y >= GAME_HEIGHT - 1)
    {
        printf("[SNAKE] Border collision!\r\n");
        return true;
    }
    
    return false;
}

// Check if snake hits itself
static bool check_self_collision(void)
{
    for (int i = 1; i < snake_length; i++)
    {
        if (snake[0].x == snake[i].x && snake[0].y == snake[i].y)
        {
            printf("[SNAKE] Self collision!\r\n");
            return true;
        }
    }
    
    return false;
}

// Update game logic
static void update_game(void)
{
    if (current_state != SNAKE_STATE_PLAYING)
        return;
    
    // Update direction from buffered input
    current_direction = next_direction;
    
    printf("[SNAKE] Update: Dir=%d, Head=(%d,%d)\r\n", current_direction, snake[0].x, snake[0].y);
    
    // Move snake body (from tail to head)
    for (int i = snake_length - 1; i > 0; i--)
    {
        snake[i].x = snake[i - 1].x;
        snake[i].y = snake[i - 1].y;
    }
    
    // Move head in current direction
    switch (current_direction)
    {
        case DIRECTION_UP:
            snake[0].y--;
            break;
        case DIRECTION_DOWN:
            snake[0].y++;
            break;
        case DIRECTION_LEFT:
            snake[0].x--;
            break;
        case DIRECTION_RIGHT:
            snake[0].x++;
            break;
    }
    
    // Check collisions
    if (check_collision() || check_self_collision())
    {
        current_state = SNAKE_STATE_OVER;
        game_running = false;
        return;
    }
    
    // Check if snake ate food
    if (snake[0].x == food_x && snake[0].y == food_y)
    {
        printf("[SNAKE] Food eaten! Score: %d -> %d\r\n", score, score + 1);
        score++;
        
        // Grow snake
        if (snake_length < MAX_SNAKE_LENGTH)
        {
            snake_length++;
            // New tail segment (will be positioned correctly on next update)
            snake[snake_length - 1] = snake[snake_length - 2];
        }
        
        // Spawn new food
        spawn_food();
    }
}

// Draw a block on screen
static void draw_block(int x, int y, bool filled)
{
    int pixel_x = x * BLOCK_SIZE;
    int pixel_y = y * BLOCK_SIZE + GAME_Y_OFFSET;  // Add offset for score area
    
    if (filled)
    {
        // Draw filled block
        for (int i = 0; i < BLOCK_SIZE; i++)
        {
            for (int j = 0; j < BLOCK_SIZE; j++)
            {
                ssd1306_DrawPixel(pixel_x + i, pixel_y + j, White);
            }
        }
    }
    else
    {
        // Draw outline only
        for (int i = 0; i < BLOCK_SIZE; i++)
        {
            ssd1306_DrawPixel(pixel_x + i, pixel_y, White);
            ssd1306_DrawPixel(pixel_x + i, pixel_y + BLOCK_SIZE - 1, White);
        }
        for (int j = 0; j < BLOCK_SIZE; j++)
        {
            ssd1306_DrawPixel(pixel_x, pixel_y + j, White);
            ssd1306_DrawPixel(pixel_x + BLOCK_SIZE - 1, pixel_y + j, White);
        }
    }
}

// Draw the game
static void draw_game(void)
{
    ssd1306_Fill(Black);
    
    // Draw score at top (above game area)
    char score_text[16];
    snprintf(score_text, sizeof(score_text), "Score:%d", score);
    ssd1306_SetCursor(2, 2);
    ssd1306_WriteString(score_text, Font_7x10, White);
    
    // Draw border
    for (int x = 0; x < GAME_WIDTH; x++)
    {
        draw_block(x, 0, false);
        draw_block(x, GAME_HEIGHT - 1, false);
    }
    for (int y = 0; y < GAME_HEIGHT; y++)
    {
        draw_block(0, y, false);
        draw_block(GAME_WIDTH - 1, y, false);
    }
    
    // Draw food
    draw_block(food_x, food_y, true);
    
    // Draw snake
    for (int i = 0; i < snake_length; i++)
    {
        draw_block(snake[i].x, snake[i].y, true);
    }
    
    ssd1306_UpdateScreen();
}

// Draw game over screen
static void draw_game_over(void)
{
    ssd1306_Fill(Black);
    
    ssd1306_SetCursor(25, 10);
    ssd1306_WriteString("GAME OVER", Font_7x10, White);
    
    char score_text[32];
    snprintf(score_text, sizeof(score_text), "Score: %d", score);
    ssd1306_SetCursor(35, 25);
    ssd1306_WriteString(score_text, Font_7x10, White);
    
    ssd1306_SetCursor(10, 45);
    ssd1306_WriteString("Press B to exit", Font_7x10, White);
    
    ssd1306_UpdateScreen();
}

// Main game loop
void snake_game(void)
{
    printf("[SNAKE] Starting snake game...\r\n");
    
    // Initialize game
    snake_reset();
    
    printf("[SNAKE] Game state after reset: %d (0=PLAYING, 1=OVER)\r\n", current_state);
    printf("[SNAKE] Entering main game loop...\r\n");
    printf("[SNAKE] Speed: 1 move every 3 seconds\r\n");
    
    // Variables for button handling
    bool button_a_prev = false;
    bool button_b_prev = false;
    int frame_counter = 0;
    
    // Main game loop - runs at higher frequency for button responsiveness
    while (game_running)
    {
        // Poll buttons directly (like Space Invaders does)
        bool button_a_current = BUTTON_A_IS_PRESSED;
        bool button_b_current = BUTTON_B_IS_PRESSED;
        
        // Detect button A press (rising edge)
        if (button_a_current && !button_a_prev)
        {
            printf("[SNAKE] Button A pressed - turning left\r\n");
            snake_button_left_pressed();
        }
        button_a_prev = button_a_current;
        
        // Detect button B press (rising edge)
        if (button_b_current && !button_b_prev)
        {
            printf("[SNAKE] Button B pressed - turning right\r\n");
            snake_button_right_pressed();
        }
        button_b_prev = button_b_current;
        
        // Update game logic periodically based on FRAMES_PER_MOVE
        frame_counter++;
        if (frame_counter >= FRAMES_PER_MOVE)
        {
            update_game();
            draw_game();
            frame_counter = 0;
        }
        
        // Small delay for button polling (10 ticks)
        tx_thread_sleep(10);
    }
    
    // Game over
    printf("[SNAKE] Game over! Final score: %d\r\n", score);
    draw_game_over();
    
    // Wait for button B to exit
    while (current_state == SNAKE_STATE_OVER)
    {
        if (BUTTON_B_IS_PRESSED)
        {
            // Wait for button release
            while (BUTTON_B_IS_PRESSED)
            {
                tx_thread_sleep(5);
            }
            printf("[SNAKE] Exiting game...\r\n");
            break;
        }
        tx_thread_sleep(10);
    }
    
    // Return to menu
    menu_set_active(true);
    menu_display();
}
